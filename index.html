
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Live Wrapper</title>
    <link href="vidstack.css" rel="stylesheet" type="text/css">
    <link href="demo.css" rel="stylesheet" type="text/css">
    <script src="https://kit.fontawesome.com/41aa90cc96.js" crossorigin="anonymous"></script>

    <style>
      livestream-wrapper:not(:defined) {
        visibility: hidden;
      }
      .fadeOut {
        visibility: hidden;
        opacity: 0;
        transition: visibility 0s 300ms, opacity 300ms ease-in-out;
      }
      .fadeIn {
        visibility: visible;
        opacity: 1;
        transition: visibility 0s 300ms, opacity 300ms ease-in-out;
      }
      vds-media:not(:defined) {
        visibility: hidden;
      }
  </style>
  </head>
  <body>
    <article class="container">
      
      <livestream-wrapper
        start="Mon Nov 20 2022 15:05:02 GMT-0500"
        end="Mon Nov 20 2022 15:07:02 GMT-0500"
        >

        <div slot="landing" class="landing playerblock">
          <button data-click>Play</button>
        </div>

        <div slot="start" class="start playerblock">
          <section>
            <h1>Preshow Banner</h1>
            <div><span data-countdown-clock></span>, <span data-countdown></span></div>
            <div><span data-localDate></span> <span data-localTime></span></div>
          </section>
        </div>

        <div slot="player" class="live playerblock sixteen_by_nine">
          <vds-media autoplay class="sixteen_by_nine" autoplay can-play can-started autoplay-error>
              <vds-video poster="test_media/poster.png" class="sixteen_by_nine">
                <video autoplay src="test_media/720p.mp4" class="sixteen_by_nine"></video>
              </vds-video>
              <article class="media-controls">
                <header class="controls_header">
                  Live
                </header>
                <section class="controls_body">
                  <vds-play-button class="big_play"></vds-play-button>
                </section>
                <section class="controls_footer">
                  <div class="controls_row2">
                    <div class="group_a">
                      <vds-play-button>
                        <i class="fa-solid fa-play media-play-icon"></i>
                        <i class="fa-solid fa-pause media-pause-icon"></i>
                      </vds-play-button>
                      <vds-mute-button>
                        <svg class="media-mute-icon" aria-hidden="true" viewBox="0 0 24 24">
                          <path
                            fill="currentColor"
                            d="M5.889 16H2a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h3.889l5.294-4.332a.5.5 0 0 1 .817.387v15.89a.5.5 0 0 1-.817.387L5.89 16zm14.525-4l3.536 3.536l-1.414 1.414L19 13.414l-3.536 3.536l-1.414-1.414L17.586 12L14.05 8.464l1.414-1.414L19 10.586l3.536-3.536l1.414 1.414L20.414 12z"
                          />
                        </svg>
                        <svg class="media-unmute-icon" aria-hidden="true" viewBox="0 0 24 24">
                          <path
                            fill="currentColor"
                            d="M5.889 16H2a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h3.889l5.294-4.332a.5.5 0 0 1 .817.387v15.89a.5.5 0 0 1-.817.387L5.89 16zm13.517 4.134l-1.416-1.416A8.978 8.978 0 0 0 21 12a8.982 8.982 0 0 0-3.304-6.968l1.42-1.42A10.976 10.976 0 0 1 23 12c0 3.223-1.386 6.122-3.594 8.134zm-3.543-3.543l-1.422-1.422A3.993 3.993 0 0 0 16 12c0-1.43-.75-2.685-1.88-3.392l1.439-1.439A5.991 5.991 0 0 1 18 12c0 1.842-.83 3.49-2.137 4.591z"
                          />
                        </svg>
                      </vds-mute-button>
                      <vds-volume-slider>
                        <div class="slider-track"></div>
                        <div class="slider-track fill"></div>
                        <div class="slider-thumb-container">
                          <div class="slider-thumb"></div>
                        </div>
                      </vds-volume-slider>
                      <div class="live_icon">Live</div>
                    </div>
                    <div class="group_b">
                      <vds-fullscreen-button>
                        <i class="fa-solid fa-expand media-enter-fs"></i>
                      </vds-fullscreen-button>
                    </div>
                  </div>
                </section>
              </article>

            <div class="media-buffering-container">
              <svg class="media-buffering-icon" fill="none" viewBox="0 0 120 120" aria-hidden="true">
                <circle
                  class="media-buffering-track"
                  cx="60"
                  cy="60"
                  r="54"
                  stroke="currentColor"
                  stroke-width="8"
                ></circle>
                <circle
                  class="media-buffering-track-fill"
                  cx="60"
                  cy="60"
                  r="54"
                  stroke="currentColor"
                  stroke-width="10"
                  pathLength="100"
                ></circle>
              </svg>
            </div>
          </vds-media>
        </div>

        <div slot="end" class="end playerblock">
          <h1>The Event is Over, Thanks for Watching</h1>
        </div>

      </livestream-wrapper>

      <hr />

      <h4>Testing</h4>
      <label>Start <input type="datetime-local" id="start"></label>
      <label>End <input type="datetime-local" id="end"></label>
      <button id="setTime">Set</button>

      <button id="simpleTest" title="Set to 30 seconds before start then run for 30 seconds.">30sec Test</button>

    </article>
  </body>

  <script type="module" src="https://cdn.jsdelivr.net/npm/@vidstack/player@next/cdn/bundle.js"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/@vidstack/player@next/cdn/define/vds-media.js"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/@vidstack/player@next/cdn/define/vds-mute-button.js"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/@vidstack/player@next/cdn/define/vds-volume-slider.js"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/@vidstack/player@next/cdn/define/vds-play-button.js"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/@vidstack/player@next/cdn/define/vds-slider-video.js"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/@vidstack/player@next/cdn/define/vds-fullscreen-button.js"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/@vidstack/player@next/cdn/define/vds-time.js"></script>

<script type="module">
export class LiveStreamWrapper extends HTMLElement {
  #isInit = false;
  #divs;
  #intervals = {
    clock: undefined
  };
  #time = {
    relativeStart: undefined,
    countdownClock: undefined,
    startlocaltime: undefined,
    startlocaldate: undefined,
  };
  #status = 'inital';
  #isWaiting  = false;
  #isLive = false;
  #isOver = false;
  #isEndOverride = false;
  #hasSeeked = false;
  #hasInteracted = false;

  // Params
  #start; // ISO 8601
  #end;
  #duration; // in seconds.
  #isLiveToVOD = false; // Bool to show video once over.

  css = `<style>
    .hidden {
      display: none;
    }
  </style>`;

  constructor() {
    super();
    if (this.isConnected) {
      this.#init();
    }

    /* We still want the clock running if the real clock is still ticking.
    window.addEventListener("offline", () => {
      this.#stopClock();
    });
    window.addEventListener("online", () => {
      this.#startClock();
    });
    window.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        this.#startClock();
      } else {
        this.#stopClock();
      }
    });
    */

  }

  static get observedAttributes() {
    return [
      'start',
      'end',
      'duration',
      'live-to-vod'
    ];
  }

  attributeChangedCallback() {
    this.#create();
  }

  set start(item) {
    this.setAttribute('start', item);
  }
  set end(item) {
    this.setAttribute('end', item);
  }
  set duration(item) {
    this.setAttribute('duration', item);
  }
  set liveToVod(item) {
    this.setAttribute('live-to-vod', item); // Works with being a bool?
  }
  set hasInteracted(item) {
    this.#hasInteracted = item;
    this.#init();
  }
  get time() {
    return this.#time;
  }
  get start() {
    return this.#start;
  }
  get end() {
    return this.#end
  }
  get status() {
    return this.#status;
  }
  get hasInteracted() {
    return this.#hasInteracted;
  }

  connectedCallback() {
    this.#init();
  }

  #init() {
    if (this.#isInit) {
      this.#create();
      return;
    }
    this.#isInit = true;

    const template = document.createElement('template');

    template.innerHTML = `
      ${this.css}
      <section id="root"></section>
      <slot name="landing"></slot>
      <slot name="start"></slot>
      <slot name="end"></slot>
      <slot name="player"></slot>
    `;

    const shadow = this.attachShadow({ mode: 'open' });
    const html = template.content.cloneNode(true);
    shadow.appendChild(html);

    this.#divs = {
      root: this.shadowRoot?.querySelector('#root'),
      landing: this.shadowRoot?.querySelector('slot[name=landing]'),
      start: this.shadowRoot?.querySelector('slot[name=start]'),
      end: this.shadowRoot?.querySelector('slot[name=end]'),
      player: this.shadowRoot?.querySelector('slot[name=player]'),
      countdown: this.querySelector('[data-countdown]'),
      countdownClock: this.querySelector('[data-countdown-clock]'),
      localTime: this.querySelector('[data-localtime]'),
      localDate: this.querySelector('[data-localDate]'),
    };

    this.#create();
  }

  #create() {

    this.#start    = this.getAttribute('start') || ''; // Required.
    this.#end      = this.getAttribute('end') || '';
    this.#duration = this.getAttribute('duration') || '';
    const isLiveToVOD = this.getAttribute('live-to-vod');

    if (!this.#start) {
      console.error('A start date is required.');
      this.#event('error', 'Missing a start date.', {});
      this.setLive();
      return;
    }

    // Convert to dates.
    this.#start = new Date(this.#start);
    if (this.#end) this.#end = new Date(this.#end);

    // Check if dates are valid.
    if (!LiveStreamWrapper.isValidDate(this.#start)) {
      console.error('Not able to determine the start date.')
      this.#event('error', 'Not able to determine the start date.', {});
      return;
    }
    if (this.#end && !LiveStreamWrapper.isValidDate(this.#end)) {
      this.#event('error', 'Invalid End Date formatting.', {});
    }

    // Start is before end.
    if (this.#end) {
      if (this.#start > this.#end) {
        console.warn('Event start is after end date.');
        this.#event('error', 'Event start is after end date.', {});
        this.#end = undefined;
      }
    }

    // Duration is a number.
    if (this.#duration) {
      this.#duration = Number(this.#duration);
      if (Number.isNaN(this.#duration)) {
        console.warn( `Duration is not a number we can use: "${this.getAttribute('duration')}"`)
        this.#event('error', `Duration is not a number we can use: "${this.getAttribute('duration')}"`, {})
        this.#duration = undefined;
      }
    }

    // attribute boolean fix. live-to-vod="false" will be false.
    if (isLiveToVOD !== null) {
      this.#isLiveToVOD = isLiveToVOD === 'true' ? true : false;
    }

    if (!this.#end && this.#duration) {
      const end = new Date();
      this.#end = new Date(end.setSeconds(this.#start.getSeconds() + this.#duration));
    }
    if (!this.#end && !this.#duration) {
      const maybeVideo = this.querySelector('video');
      if (maybeVideo) {
        this.#end = maybeVideo.duration;
      } else {
        const end = new Date();
        this.#end = new Date(end.setSeconds(this.#start.getSeconds() + 10));
      }
    }
    if (!this.#end && !this.#duration) {
      console.warn('No end date or duration set, will try using the video ending event.');
    }

    if (this.#getState(this.#start, this.#end) === 'end') {
      this.#setState(this.#start, this.#end);
      this.#startClock();
      return;
    }

    if (this.#hasInteracted) {
      this.#setState(this.#start, this.#end);
      this.#startClock();
      return;      
    }

    this.setLanding();
    const startButton = this.querySelector('[data-click]');
    if (startButton) {
      startButton.addEventListener('click', async () => {
        await LiveStreamWrapper.fadeOut(startButton);
        this.#startClock();
        this.#setState(this.#start, this.#end);
        this.#hasInteracted = true;
      });
    } else {
      this.#startClock();
      this.#setState(this.#start, this.#end);
    }
  }

  #getState(start, end) {
    const now = new Date();
    switch(true) {
      case now > end || this.#isEndOverride:
        return 'end';
      case now > start:
        return 'live';
      case now < start:
        return 'pre';
      default:
        return '';
    }
  }

  #setState(start, end) {
    this.#status = this.#getState(start, end);
    if (this.#status === 'end') this.setEnd();
    if (this.#status === 'live') this.setLive();
    if (this.#status === 'pre') this.setStart();
  }

  setLanding() {
    this.#showLanding();
    this.#hidePregame();
    this.#hidePlayer();
    this.#hidePostgame();
  }

  setStart() {
    this.#hideLanding();
    this.#showPregame();
    this.#hidePlayer();
    this.#hidePostgame();

    if (!this.#isWaiting) {
      this.#event('pre', 'Event has not yet started', {});
      // Make sure video is not already playing in background on page load.
      if (this.#getState(this.#start, this.#end) === 'pre') {
        const player = this.querySelector('video');
        if (player) player.pause();
      }
      this.#isWaiting = true;
    }
  }

  setLive() {
    this.#hideLanding();
    this.#hidePregame();
    this.#showPlayer();
    this.#hidePostgame();

    if (!this.#isLive) {
      this.#event('isLive', 'Is Live', {});
      const player = this.querySelector('video');
      if (player) {
        if (player.paused) player.play();
        player.onplay = () => {
          //if (!this.#hasSeeked) {
            this.#event('seeking', 'seeing to wallclock time', {});
            const offset = (new Date() - this.#start) / 1000;
            player.currentTime = offset;
            //this.#hasSeeked = true;
          //}
        }
        player.onended = () => {
          this.#isEndOverride = true;
          this.#setState(this.#start, this.#end);
        }
      }
      this.#isLive = true;
    }

  }

  setEnd() {
    this.#hideLanding();
    this.#hidePregame();
    if (!this.#isLiveToVOD) {
      this.#hidePlayer();
      this.#showPostgame();
    }
    if (this.#isLiveToVOD) {
      this.#hidePostgame();
    }

    const player = this.querySelector('video');
    if (player) player.pause();

    //this.#stopClock();
    if (!this.#isOver) {
      this.#event('end', 'Event has ended', {});
      this.#isOver = true;
    }
  }

  #showLanding() {
    this.#divs.landing.classList.remove('hidden');
  }
  #hideLanding() {
    this.#divs.landing.classList.add('hidden');
  }
  #showPregame() {
    this.#divs.start.classList.remove('hidden');
  }
  #hidePregame() {
    this.#divs.start.classList.add('hidden');
  }
  #showPlayer() {
    this.#divs.player.classList.remove('hidden');
  }
  #hidePlayer() {
    this.#divs.player.classList.add('hidden');
  }
  #showPostgame() {
    this.#divs.end?.classList.remove('hidden');
  }
  #hidePostgame() {
    this.#divs.end.classList.add('hidden');
  }

  #startClock() {
    this.#clock();
    this.#intervals.clock = setInterval(() => this.#clock(), 100);
  }

  #stopClock() {
    clearInterval(this.#intervals.clock);
  }

  #clock() {
    if (this.#start) {
      this.#time.relativeStart  = LiveStreamWrapper.getRelativeTimeDistance(this.#start);
      this.#time.countdownClock = LiveStreamWrapper.getCountdownClock(this.#start);
      this.#time.startlocaltime = LiveStreamWrapper.startLocalTime(this.#start);
      this.#time.startlocaldate = LiveStreamWrapper.startLocalDate(this.#start);
      if (this.#divs.countdown) {
        this.#divs.countdown.innerHTML = this.#time.relativeStart;
      }
      if (this.#divs.countdownClock) {
        this.#divs.countdownClock.innerHTML = this.#time.countdownClock;
      }
      if (this.#divs.localTime) {
        this.#divs.localTime.innerHTML = this.#time.startlocaltime;
      }
      if (this.#divs.localDate) {
        this.#divs.localDate.innerHTML = this.#time.startlocaldate;
      }

      // Set state of Block
      this.#setState(this.#start, this.#end);

    } else {
      console.warn('No start time set.');
    }
  }

  #event(name, details, object) {
    this.dispatchEvent(new CustomEvent('all', {detail: {"name": name, "message": details, "full": object}}));
    this.dispatchEvent(new CustomEvent(name, {detail: {"message": details, "full": object}}));
  }

  static getRelativeTimeDistance(d1, d2 = new Date() ) {
    const units = {
      year  : 24 * 60 * 60 * 1000 * 365,
      month : 24 * 60 * 60 * 1000 * 365/12,
      day   : 24 * 60 * 60 * 1000,
      hour  : 60 * 60 * 1000,
      minute: 60 * 1000,
      second: 1000
    }
    const rtf = new Intl.RelativeTimeFormat('en', { numeric: 'auto' })
    const elapsed = d1 - d2;
    for (const u in units)
      if (Math.abs(elapsed) > units[u] || u == 'second')
        return rtf.format(Math.round(elapsed/units[u]),u)
  }

  static startLocalTime(time) {
    return time.toLocaleTimeString('en-us',{timeZoneName:'short', hour: 'numeric', minute: '2-digit'});
  }

  static startLocalDate(time) {
    return time.toLocaleDateString('en-us',{month: 'long', day: 'numeric', year: 'numeric'});
  }

  static getCountdownClock(countDownDate) {
    const now = new Date().getTime();
    const distance = countDownDate - now;
    const hours  = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    let mins   = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60)).toString();
    let sec    = Math.floor((distance % (1000 * 60)) / 1000).toString();

    if (Number(sec) < 10) sec = `0${sec}`;
    if (Number(mins) < 10) mins = `0${mins}`;

    if (distance > 0) {
      return `${hours || '00'}:${mins || '00'}:${sec || '00'}`;
    }
    return `00:00:00`;
  }

  static isValidDate(d) {
    if (Object.prototype.toString.call(d) === "[object Date]") {
      if (Number.isNaN(d)) {
        return false;
      }
      return true;
    }
    return false;
  }

  static async fadeOut(div) {
    div.classList.add('fadeOut');
    div.classList.remove('fadeIn');
    return new Promise(resolve => {
      div.addEventListener('transitionend', () => {
        div.remove();
        resolve();
      });
    });
  }

  async #fadeIn(div) {
    div.classList.add('fadeIn');
    return new Promise(resolve => {
      div.addEventListener('transitionend', resolve);
    });
  }
}
window.customElements.define('livestream-wrapper', LiveStreamWrapper);
</script>



<!-- For Testing -->
<script type="module">
  const start = document.querySelector('#start');
  const end = document.querySelector('#end');
  const livewrap = document.querySelector('livestream-wrapper');

  const tzoffset = (new Date()).getTimezoneOffset() * 60000;

  if (livewrap.start) {
    const startDate = (new Date(livewrap.start - tzoffset)).toISOString().split('.')[0];
    start.value = startDate;
  }

  if (livewrap.end) {
    const endDate = convertToDateInput(livewrap.end)
    end.value = endDate;
  }

  document.querySelector('#setTime').addEventListener('click', () => {
    livewrap.start = start.value;
    livewrap.end = end.value;
  });

  start.addEventListener('change', event => {
    if (!event.target.value) return;
    const date = new Date(event.target.value);
    const endDate = date.setTime(date.getTime() + 60 * 1000);
    end.value = convertToDateInput(endDate);
  });
  end.addEventListener('change', event => {
    //livewrap.end = event.target.value;
  });
  livewrap.addEventListener('all', event => {
    console.log('Event: ', event.detail);
  });
  

  const simpleTest = document.querySelector('#simpleTest');
  simpleTest.addEventListener('click', () => {
    const now = new Date();
    const newStart = now.setTime(now.getTime() + 30 * 1000); // +30sec.

    const newStartDate = new Date(newStart);
    const newEnd = newStartDate.setTime(newStartDate.getTime() + 30 * 1000); // Ends 30sec after.
    console.log(new Date(newStart), new Date(newEnd));

    start.value = convertToDateInput(new Date(newStart));
    end.value = convertToDateInput(new Date(newEnd));

    livewrap.start = new Date(newStart)
    livewrap.end = new Date(newEnd)

  })

  function convertToDateInput(date) {
    return (new Date(date - tzoffset)).toISOString().split('.')[0];
  }

</script>

</html>